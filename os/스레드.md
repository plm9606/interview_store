**contents**

- [스레드](#스레드)
- [사용자 수준 스레드와 커널 수준 스레드의 차이](#사용자-수준-스레드와-커널-수준-스레드의-차이)
  - [사용자 수준 스레드](#사용자-수준-스레드)
  - [커널 수준 스레드:](#커널-수준-스레드:)
- [프로세스와 스레드](#프로세스와-스레드)

# 스레드

## 스레드

스레드는 한 프로세스 안에서 동작하는 실행 흐름들을 의미한다.
스레드는 프로세스 내의 공간/자원을 공유한다. (코드, 데이터 섹션, 파일, 신호 등등의 운영체제 자원)

> ❓ **스택을 스레드마다 독립적으로 할당하는 이유는?**

스레드는 독립적인 작업이 가능해야 하기 때문이다.
스택은 되돌아갈 주소값이나 변수 등을 저장하는 곳이다. 이런 스택 공간이 독립적이어냐 독립적인 실행 context를 가질 수 있고 독립적인 실행이 가능하게 된다.

> 스레드도 context-switching을 하는가?

|      | 멀티 스레드                                  | 멀티 프로세스                                              |
| ---- | -------------------------------------------- | ---------------------------------------------------------- |
| 장점 | 적은 memory 차지(자원공유), 문맥 전환이 빠름 | 한 프로세스가 죽어도 다른 프로세스에는 영향이 가지 않는다. |
| 단점 | 공유자원이 망가질 경우 모든 스레드에 영향    | 많든 memory와 cpu 차지                                     |

</br>

## 사용자 수준 스레드와 커널 수준 스레드의 차이

### 사용자 수준 스레드

라이브러리에 의해 구현된 일반적인 스레드

**장점**

- 사용자 수준 스레드는 context switch가 없다. 따라서 커널 스레드보다 오버헤드가 적다. 스레드 전환 시 커널 스케쥴러를 호출할 필요가 없기 때문.
- 사용자 수준 스레드에서는 스레드 스케쥴러가 사용자 모드에만 존재한다.

**단점**

- 프로세스 내의 한 스레드가 커널로 진입하는 순간 나머지 스레드들도 전부 정지됨. 이는 커널이 스레드의 존재를 알지 못하기에 발생하는 현상임.

### 커널 수준 스레드:

`커널`이 직접 생성하고 관리하는 스레드. 사용자 스레드가 커널 스레드를 사용하려면 시스템 호출로 커널 기능을 이용해야 한다.

**장점**

- 사용자 수준 스레드보다 효율적이다.
- 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있는 장점이 있다.
  - 사용자 스레드는 CPU가 아무리 많더라도 커널 모드의 스케쥴이 되지 않으므로 각 CPU에 효율적으로 스레드를 배당할 수 없다.

단점

- 커널 스케쥴러를 통해 context switch가 발생한다. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 빈번할 수록 성능이 하락한다.

## 프로세스와 스레드

[블로그 참고](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
