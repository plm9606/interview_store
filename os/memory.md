**💌CONTENTS**

- [메모리](#메모리)
- [메모리 주소](#메모리-주소)
  - [절대주소](#절대주소)
  - [논리주소](#논리주소)
  - [주소 바인딩](#주소-바인딩)
    - [컴파일 타임 바인딩](#컴파일-타임-바인딩)
    - [로드 타임 바인딩](#로드-타임-바인딩)
    - [실행 시간 바인딩(run time binding)](#실행-시간-바인딩run-time-binding)
    - [MMU 동작 방식](#mmu-동작-방식)
    - [한계 레지스터가 필요한 이유](#한계-레지스터가-필요한-이유)
  - [⚙여러가지 메모리 관리 기법](#⚙여러가지-메모리-관리-기법)
    - [동적 로딩](#동적-로딩)
    - [동적 연결](#동적-연결)
    - [스와핑](#스와핑)
  - [운영체제의 메모리 관리](#운영체제의-메모리-관리)
  - [가상 메모리](#가상-메모리)
    - [장점](#장점)
  - [요구 페이징 기법](#요구-페이징-기법)
    - [페이지 부재](#페이지-부재)
    - [페이지 교체](#페이지-교체)
    - [스레싱](#스레싱)

# 메모리

# 메모리 주소

**경계레지스터**

운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터이다.
메모리 관리자는 사용자가 작업을 요청할 때마다 경계레지스터의 값을 벗어나는지 검사한다.

<br/>

### 절대주소

메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 램 메모리의 실제 주소를 의미한다.

### 논리주소

프로세스는 실행을 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소공간이 생긴다. 이 주소를 `논리적 주소`라고 한다. 논리적 주소는 각 프로세스마다 `독립적`으로 할당되고 0부터 시작한다.

> **왜 프로세스는 논리적 주소를 사용할까?**

프로세스 입장에서 상대 주소가 사용할 수 없는 영역의 위치를 알 필요가 없고, 주소가 항상 0번지부터 시작하기 때문에 편리하다.

## 주소 바인딩

CPU가 프로세스의 작업을 수행하기 위해서 프로세스의 논리적 주소를 참조하게 된다. 논리적 주소만으로는 실제 메모리의 주소를 알 수 없기 때문에 **논리 주소를 물리적 메모리로 연결시키는 작업**이 필요하다. 이 작업을 `주소 바인딩`이라고 한다.

주소 바인딩에는

- 컴파일 타임 바인딩
- 로드 타임 바인딩
- 실행 시간 바인딩

이렇게 세가지 바인딩 방식이 있다. 세 바인딩의 기준은 **물리적 주소가 언제 결정되느냐**에 따라서 결정된다.

### 컴파일 타임 바인딩

말 그대로 컴파일 할 때 물리적 메모리 주소가 결정되는 주소 바인딩이다.
프로그램의 물리적 주소를 변경하고 싶으면 다시 컴파일해야 한다.

이 방식은 비현실적이고 현대의 시분할 컴퓨팅 환경에서는 잘 사용되지 않는 기법이다.

### 로드 타임 바인딩

프로그램의 실행이 시작될 때 물리적 주소가 결정된다.
이 바인딩에서는 `로더`가 물리적 메모리 주소를 부여하고 프로그램이 종료될 때 까지 물리주소가 고정된다.

로더: 사용자 프로그램을 메모리에 적재시키는 프로그램

### 실행 시간 바인딩(run time binding)

프로그램이 실행한 후에도 물리적 주소가 변경될 수 있는 바인딩 방식이다.
런타임 바인딩에서는 CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 `주소 매핑 테이블`을 이용해 주소 바인딩을 점검한다.
그리고 주소 매핑 테이블 뿐 만 아니라 `기준 레지스터`, `한계 레지스터`, `MMU(Memeoty Management Unit`이 필요하다.
런타임 바인딩은 메모리에 프로세스의 주소공간이 연속적으로 적재되어 있음을 가정한다.

- 기준 레지스터: 프로세스의 물리적 메모리의 시작 주소를 가지고 있다.
- 한계 레지스터: 현재 CPU에서 수행중인 프로세스의 논리적 주소의 최대값, 프로세스의 크기를 가지고 있다.
- MMU: 논리적 주소를 물리적 주소로 메핑해주는 하드웨어

![image.png](https://images.velog.io/post-images/adam2/53b752a0-327f-11ea-89c2-a9689e76c48b/image.png)

### MMU 동작 방식

기준 레지스터에는 현재 CPU에서 수행중인 프로세스의 물리적 메모리 시작 주소가 저장되어 있다. CPU가 논리적 주소 245에 있는 데이터를 요청하게 되면 **기준 레지스터에 저장된 물리적 시작 주소와 해당 논리적 주소를 더한다.** 그렇게해서 실제 메모리의 8245에 있는 데이터를 꺼내오면 된다.

**그렇다면 한번 생각해보자🤔**
프로세는 고유한 주소공간을 가지고 있다. 그리고 논리적 주소값은 프로세스마다 독립적으로 할당된다고 하였다. 프로세스A에도 100번 논리 주소가, 프로세스B에도 100번 논리주소가 있다는 말이다. 그렇지만 프로세스A의 100번 논리주소에 매핑되는 실제 물리적 주소와 프로세스B에 매핑되는 실제 물리적 주소는 다를 것이다.
따라서 MMU기법에서는 **문맥교환이 일어날 때 마다 기준 레지스터의 값을 바뀌는 프로세스에 해당되는 값으로 `재설정`을 해주어야 한다.**

### 한계 레지스터가 필요한 이유

MMU 방식에서는 `기준레지스터값 + 논리적 주소값`을 통해서 주소 바인딩을 한다.
만약 **해당 값이 해당 프로세스의 주소범위를 넘어가는 값이 된다면 어떻게 될까?** 프로세스가 접근해서는 안되는 영역을 접근할 가능성이 생긴다.
이런 문제점을 방지하기 위해서 한계레지스터를 사용하는 것이다.
한계 레지스터에 최대 논리적 주소값을 저장하고 CPU가 논리적 주소를 요청할 때 마다 한계 레지스터 값보다 작은 값인지를 검사하게 된다.

## ⚙여러가지 메모리 관리 기법

### 동적 로딩

프로세스가 실행될 때 프로세스 주소공간 전체를 메모리에 올리지 않고, 필요한 부분만 그때 그때 메모리에 적재하는 방식

- 메모리 효율적 사용 가능
- 프로스램 자체에서 구현 가능

### 동적 연결

linking: 소스코드를 컴파일하여 이미 컴파일된 라이브러리 파일들과 묶어(linking) 하나의 실행파일을 생성하는 것

동적 연결은 컴파일한 소스코드와 라이브러리파일을 바로 연결하지 않고 프로그램이 실행되고 라이브러리 함수를 호출할 때 라이브러리 파일과 linking하는 방식.

- 실행 파일에 라이브러리 코드가 포함되지 않는다.
- 공통으로 사용하는 라이브러리를 메모리에 한번만 적재해서 메모리 효율 ↑
- 운영체제의 지원 필요

### 스와핑

메모리에 올라온 프로세스의 주소공간 전체를 디스크의 swap 영역으로 이동시키는 것을 말한다.

swap 영역은 backing store라고도 부르고, 디스크 내에 파일 시스템과는 별도로 존재하는 영역이다.

스와핑을 하는 이유는 메모리에 너무 많은 프로세스가 적재되어서 시스템 성능이 떨어지게 되면 그중 당장 사용하지 않는 몇개의 프로세스를 스왑 영역으로 내쫒아 메모리공간을 확보하기 위해서이다.

이 작업은 중기 스케줄러가 담당하여 처리한다.

![image.png](https://images.velog.io/post-images/adam2/831fd460-3282-11ea-bcba-71396290533a/image.png)

# 운영체제의 메모리 관리

운영체제는 자원의 효율적인 관리를 도맏아 하는 소프트웨어이다.
따라서 운영체제는 어떤 프로그램에 얼마만큼의 메모리를 할당해야 할지를 결정해야한다.

메모리 할당 방법에는

- 균등 할당
- 비례 할당
- 우선순위 할당

세가지 방법이 있다.
균등할당은 프로세스마다 동일한 메모리를 할당하는 방식이고, 비례할당은 프로세스의 크기에 비례하게 메모리를 할당하는 방식, 우선순위 할당은 우선순위가 높은 프로세스에게 더 많은 메모리를 할당하는 방식이다.

또한 운영체제는 프로세스를 통째로 메모리에 올릴 수 있지만 CPU에서 당장 수행해야 할 부분만 메모리에 올리고 나머지는 디스크의 swap 영역에 두어 메모리를 효율적으로 사용한다.
