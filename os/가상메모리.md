**💌CONTENTS**

- [가상 메모리](#가상-메모리)
    - [장점](#장점)
    - [가상 메모리의 메모리 분할 방식](#가상-메모리의-메모리-분할-방식)
  - [요구 페이징 기법](#요구-페이징-기법)
    - [페이지 부재](#페이지-부재)
    - [페이지 교체](#페이지-교체)
    - [스레싱](#스레싱)

# 가상 메모리

**가상 메모리**는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다.

운영체제는 프로그램이 자기 자신만의 가상 메모리를 사용하는 것처럼 가정해 프로그램 하는 것을 지원한다. 가상 메모리 주소 공간은 `논리적 주소(가상주소)`로서 모든 프로그램마다 0부터 시작하게 된다.
즉, 가상메모리는 프로세스마다 논리적 주소공간을 가지고 이 주소공간의 일부는 물리적 메모리에 적재되고 일부는 스왑영역에 존재한다.

하지만 우리가 흔히 말하는 논리 주소와는 의미가 약간 다르다. 논리주소는 물리 메모리의 공간에 비례하고, 가상주소는 물리 메모리 공간이 아닌 가상의 주소공간을 가진다는 것이다. (물리 메모리에 비례하지 않음)

이론적으로 가상메모리는 무한대의 크기이지만 실제로 가상 메모리의 최대 크기는 해당 컴퓨터의 물리 메모리의 최대 크기로 한정된다.

- 가상메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 `물리 메모리(실제 메모리) + 스왑영역` 이다.

### 장점

- 메모리 사용량 감소 (프로세스 일부만 올리니까)
- 입출력 오버헤드 감소 ( 일부만 디스크 -> 메모리 입출력 하니까)
- 시스템이 더 많은 프로세스를 수용할 수 있다.
- 프로그램이 물리적 메모리의 용량 제약에서 자유롭다 (메모리보다 큰 프로그램 실행 가능)

### 가상 메모리의 메모리 분할 방식

가상 메모리 시스템도 일반 메모리 분할방식과 마찬가지로 가변 분할 방식과 고정 분할 방식으로 나뉜다.

가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법을 `세그멘테이션` , 고정 분할 방식을 이용한 메모리 관리 기법을 `페이징`이라고 한다.

<table>
<th>구분</th>
<th>가상 메모리</th>
<th>물리 메모리</th>
<tr>
<td>최대 메모리 크기</td>
<td>CPU 비트 값에 의존</td>
<td>CPU 비트 값에 의존</td>
</tr>
<tr>
<td rowspan="3">방식</td>
<td>세그멘테이션</td>
<td>가변 분할 방식</td>
</tr>
<tr>
<td>페이징</td>
<td>고정 분할 방식</td>	
</tr>
<tr>
<td>세그멘테이션-페이징 혼용 기법</td>
<td></td>	
</tr>
<tr>
<td>주소지정방식</td>
<td>가상주소</td>
<td>절대주소, 상대주소</td>
</tr>
<table>

가상메모리 기법은 프로세스의 주소공간을 적재하는 단위에 따라 `요구 페이징 기법`과 `요구 세그멘테이션 기법` 두개로 나눌 수 있다.

## 요구 페이징 기법

페이지 단위로 프로세스의 주소공간을 메모리에 적재하며 당장 사용될 페이지만을 메모리에 적재한다.

사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 요구 페이징이라고 한다.

### 페이지 부재

CPU에서 요청한 페이지가 현재 메모리에 없어 페이지 테이블의 `유효-무효 비트`가 무효로 세팅되어 있는 경우를 말한다.
페이지 부재 발생 시 페이지를 디스크에서 읽어와야 하는데 이 과정에서 막대한 overhead가 발생한다. 따라서 요구 페이징 기법은 페이지 부재 발생률이 성능에 큰 영향을 끼친다.

**페이지 부재 시 동작 과정**

1. MMU(Memory Management Unit)가 페이지 부재 트랩을 발생시킨다. (트랩=소프트웨어 인터럽트)
2. 인터럽트로 인해 커널모드로 전환되어 OS의 페이지 부재 처리 루틴이 호출된다.
3. 해당 부재 페이지의 보호비트를 참조해 접근이 가능한지 체크한다.
4. 물리메모리에 비어있는 프레임을 할당받고 그곳에 페이지를 읽어온다.
5. 페이지를 읽어오는 동안 프로세스는 wait상태가 된다.
6. 디스크 입출력 완료시 인터럽트를 발생시키고 해당 페이지의 유효-무효 비트를 유효로 세팅한다

### 페이지 교체

페이지 부재 발생시 메모리에 해당 페이지를 적재해야 하는데 이때 메모리가 꽉찼다면 어떡해야 할까??
이때는 메모리에 있는 페이지중 가장 쓸모 없어보이는 것을 골라 스왑 영역으로 쫒아내고 그 자리에 페이지 부재된 페이지를 적재해야 한다. 이 과정이 페이지 교체이다.

교체할 페이지를 선정할 때 교체 대상이 될 프레임의 범위에 따라 `전역 교체`와 `지역 교체`로 나눌 수 있다.
전역교체 방법은 모든 페이지 프레임이 교체 대상이 될 수 있는 방법이다. 지역 교체 방법은 현재 수행중인 프로세스에게 할당된 페이지 프레임 내에서만 페이지 교환을 하는 방법이다.

**페이지 교체 알고리즘**

- 최적 교체(OPT) 알고리즘
- FIFO
- LRU(Least Recently Used)
- LFU(Least Frequently Used)
- NUR(Not Used Recently)

#### 최적 페이지 교체 알고리즘

각 페이지의 호출 순서를 미리 알고있는 전제 하에 알고리즘을 운영
가장 먼 미래에 호출될 페이지와 교체한다.
실제로 구현할수 없다.

#### LRU

가장 과거에 호출되었던 페이지와 교체한다.
`시간 지역성`을 활용

> 최근에 참조된 페이지가 다시 참조될 가능성이 높다

#### LFU

가장 적은 횟수로 참조된 페이지와 교체한다.
`Incache-LFU`, `Perfect-LFU`

#### NUR(클럭 알고리즘)

`LRU 근사 알고리즘`이다.
LRU처럼 오랫동안 참조하지 않은 페이지중 하나를 선택하지만 가장 오래된 페이지라는 보장은 없다.
`하드웨어적 지원`을 통해 알고리즘을 운영해 오버헤드를 줄임
페이지 프레임의 `참조 비트`를 조사해서 참조비트가 `0`인 페이지를 찾으면 그 페이지와 교체한다

### 스레싱

프로세스의 처리 시간보다 페이지 교체에 드는 시간이 더 많아져 CPU이용률이 떨어지는 현상을 말한다.
다중프로그래밍정도가 높아지면 어느정도 까지는 CPU이용률이 오르지만, 한계치를 넘으면 스레싱이 발생하고 CPU이용률이 급감한다.

> 다중프로그래밍정도: 메모리에 동시에 올라가 있는 프로세스의 수

**해결책**

- 다중프로그래밍정도를 적정 수준으로 유지한다.
- 페이지 부재 빈도를 조절한다
- working set을 유지한다
- 일부 프로세스를 중단한다

