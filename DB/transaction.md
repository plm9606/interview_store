# 트랜잭션

트랜잭션은 작업의 `완전성`을 보장해 주는 것이다. 즉 논리적인 작업셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원상태로 복구해 작업의 일부만 적용되는 현상이 발생하지 않도록 만들어주는 기능이다. 부분 업데이트 현상이 발생하면 실패한 쿼리로 인해 남은 레코드를 자시 삭제하는 재처리 작업이 필요해질 수 있다. 트랜잭션을 사용하면 이 과정을 편리하게 구현할 수 있다.

잠금과 트랜잭션은 서로 비슷한 개념 같지만, 잠금은 `동시성`을 제어하기 위한 기능이고 트랜잭션은 `정합성`을 보장하기 위한 기능이다.

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.

## 트랜잭션의 특성

트랜잭션은 어떠한 특성을 만족해야할까? Transaction 은 다음의 ACID 라는 4 가지 특성을 만족해야 한다.

### 원자성(Atomicity)

만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

### 일관성(Consistency)

트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

### 고립성(Isolation)

각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

### 지속성(Durability)

트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

## 트랜잭션의 상태

트랜잭션 상태 다이어그램
![](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/transaction-status.png)

### Active

트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

### Failed

트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

### Partially Committed

트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태를 말한다.

### Committed

트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

### Aborted

트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

### Partially Committed 와 Committed 의 차이점

Commit 요청이 들어오면 상태는 Partial Commited 상태가 된다. 이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Commited는 Commit 요청이 들어왔을때를 말하며, Commited는 Commit을 정상적으로 완료한 상태를 말한다.

## 트랜잭션 격리 수준(Isolation Level)

트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.

MYSQL은 데이터 변경시 변경 전 데이터를 UNDO영역에 저장하고, 변경된 데이터는 바로바로 레코드에 저장한다. 때문에 격리된 데이터를 조회할 때 테이블에서 바로 조회하는 것이 아니라 UNDO영역에서 백업 레코드를 가져와 조회한다.

하지만, 실제로는 ACID 원칙은 종종 지켜지지 않는다. 왜냐하면 ACID 원칙을 strict 하게 지키려면 동시성이 매우 떨어지기 때문이다.

그렇기 때문에 DB 엔진은 ACID 원칙을 희생하여 동시성을 얻을 수 있는 방법을 제공한다. 바로 transaction의 isolation level이다. Isolation 원칙을 덜 지키는 level을 사용할수록 문제가 발생할 가능성은 커지지만 동시에 더 높은 동시성을 얻을 수 있다. DB 엔진은 isolation level에 따라 서로 다른 locking 전략을 취한다. 요컨대, isolation level이 높아질수록 더 많이, 더 빡빡하게 lock을 거는 것이다.

### 격리 수준에 따라 발생할 수 있는 문제점

1. DIRTY READ
   트랜잭션에서 작업이 다 안끝났는데 다른 트랜잭션에서 작업 내용을 볼 수 있는 것.
   변경 데이터가 롤백될지, 커밋될지 모르는 상황에서 작업내용 조회시 데이터 정합성에 큰 문제가 생길 수 있다.

2. NON-REPETABLE READ
   하나의 트랜잭션에는 같은 SELECT문으로 조회시 항상 같은 결과를 가져와야 한다. SELECT마다 다른 결과를 받을 수 있다면 NON-REPETABLE READ이다.

3. PHANTOM READ
   하나의 트랜잭션에서 같은 SELECT문으로 조회시 이전 SELECT에서 존재하지 않았던 값이 조회되는 경우를 말한다.

|                 | DIRTY READ | NON-REPETABLE READ | PHANTOM READ              |
| --------------- | ---------- | ------------------ | ------------------------- |
| READ UNCOMMITED | O          | O                  | O                         |
| READ COMMITED   | X          | O                  | O                         |
| REPETABLE READ  | X          | X                  | O(InnoDB는 발생하지 않음) |
| SERIALIZABLE    | X          | X                  | X                         |

### 격리 수준

1. READ UNCOMMITED
   트랜잭션에서 변경 내용이 COMMIT, ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다.

사용자 A는 emp_no가 5000000이고 first_name이 "Lara"인 새로운 사원을 insert하고 있다. 사용자 A가 변경된 내용을 커밋하기도 전에 사용자 B가 emp_no=5000000인 새로운 사원을 검색하고 있다. 하지만 A가 처리 도중 알 수 없는 문제로 롤백해버린다 하더라도 B는 "Lara"가 정상적인 사원이라고 생각하고 계속해서 처리하게 되리라는 것이다.
MySql을 사용한다면 최소한 READ COMMITED이상의 격리 수준을 사용할 것을 권장한다.

2. READ COMMITED
   트랜잭션에서 변경한 레코드는 COMMIT된 데이터만 조회할 수 있다.
   오라클에서 기본적으로 사용되는 격리 수준이다.
3. REPETABLE READ
   InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준이다.
   앞서 말했다 싶이 InnoDB는 트랜잭션이 ROLLBACK될 가능성에 대비해 변경 전 레코드를 UNDO공간에 백업해두고 실제 레코드 값을 변경한다. UNDO영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다.

모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)를 가지며, UNDO영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다. 그리고 UNDO영역의 백업 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.

4. SEREIALIZABLE
   InnoDB테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행된다. 하지만 SEREIALIZABLE 레벨에서는 읽기 작업도 공유잠금(읽기 잠금)을 획득해야만 하녀, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.

# Blocking

블로킹은 lock들의 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰선 상태를 의미한다. 공유 lock과 배타적 lock, 배타적 lock과 배타적 lock끼리 블로킹이 발생할 수 있다. 이를 해결하는 방법은 Commit 또는 rollback 뿐이다.

경합이 발생할 때, 먼저 락을 설정한 트랜잭션을 기다려야 하기 때문에 이런 현상이 반복되면 시스템 속도가 저하된다.

해결방안

- SQL 문장에 가장 빠르게 실행되도록 리펙토링하는 것이 가장 기본이며 효과적인 방법입니다.
- 트랜젝션을 가능한 짧게 정의하면 경합을 줄일 수 있습니다.
- 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계하는 것이 좋습니다. 또한 트랜젝션이 활발한 주간에는 대용량 갱신 작업을 수행하면 안됩니다.
- 대용량작업이 불가피할 경우, 작업단위를 쪼개거나 lock_timeout을 설정하여 해당 Lock의 최대시간을 설정할 수 있습니다.

# DeadLock

데드락은 트랜잭션간의 교착상태를 의미한다. 두개의 트랜잭션간에 각각의 트랜잭션이 가지고 있는 리소스의 lock을 획득하려고 할 때 발생한다.

### Case 1

![](https://miro.medium.com/max/720/1*RBAssm3L_5uDG2S-4nTWKg.png)

- 1번 트핸잭션에서 2번 리소스의 잠금을 획득, 2번 트랜잭션에서 1번 리소스의 잠금을 획득한 상태
- 여기서 서로의 데이터를 엑세스 하기 위해 서로의 lock이 해제될 때 까지 기다린다.

### Case 2

![](https://miro.medium.com/max/713/1*oyvzeTR0huqpe8GbVRZX-w.png)

- 1번 트랜잭션이 공유 lock을 설정하고 sleep에 빠짐
- 이때 2번 트랜잭션이 배타적 lock을 설정하기 위해 1번의 lock이 해재될 때 까지 무한정 기다린다.

## 교착 상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다, 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.

---

**참고**

- https://medium.com/@chrisjune_13837/db-lock-%EB%9D%BD%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-d908296d0279#:~:text=%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98%20%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%84%20%EB%B3%B4%EC%9E%A5%ED%95%98%EA%B8%B0%20%EC%9C%84%ED%95%9C%20%EB%B0%A9%EB%B2%95%EC%9E%85%EB%8B%88%EB%8B%A4.,%EC%9D%B4%20%EB%9B%B0%EC%96%B4%EB%82%98%EA%B8%B0%20%EB%95%8C%EB%AC%B8%EC%9E%85%EB%8B%88%EB%8B%A4.
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C
- Real MySQL
