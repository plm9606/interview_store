# 인덱스

인덱스(Index)란 무엇인가?
인덱스는 검색속도를 높이기위해 사용하는 기술이다. 마치 책의 색인 처럼 테이블의 칼럼을 색인화 하여 검색시 테이블의 레코드를 full scan하는 것이 아니라 index를 검색해 빠르게 검색할 수 있도록 한다.

DBMS에서 인덱스는 저장되는 칼럼의 값을 이용해 항상 정렬된 상태로 유지한다. 때문에 데이터의 저장(insert, update, delete)성능을 희생하고 읽기(select)속도를 높인다.

하지만 인덱스를 이용하는 것이 항상 좋은 것만은 아니다. 데이터를 추가적으로 사용하기 때문에 데이터 크기가 증가하고 인덱스 업테이트를 위해 추가적인 처리가 필요한다. 데이터의 양이 많을 수록 업데이트 속도가 저하되기 때문에 꼭 필요한 칼럼에만 인덱스를 부여해햐 한다.

## Index 자료구조

그렇다면 DBMS 는 인덱스를 어떻게 관리하고 있는가

### B+-Tree 인덱스 알고리즘

일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.

### Hash 인덱스 알고리즘

칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

### Fractal-Tree 알고리즘

B-Tree의 단점을 보완하기 위해 고안. B-Tree처럼 값을 변형하지 않고 인덱싱 하지만 데이터의 저장/삭제 속도가 더 빠르다.

**왜 index 를 생성하는데 b-tree 를 사용하는가?**
데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.

## 다중 컬럼 인덱스

두개 이상의 컬럼으로 구성된 인덱스를 말한다.
인덱스의 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬된다. 즉 두번째 칼럼의 정렬은 첫번째 칼럼이 똑같은 레코드에서만 의미가 있다는 것이다.
![](compound_index.jpg)

## RDBMS에서는 어떻게 최적화를 하고 있는가?

### 고유성의 보장

인덱스는 데이터의 고유성을 보증하는 목적으로 사용할 수 있다. 해시 인덱스라면 동일한 ID인 경우 반드시 동일 해시값이 되고, B+Tree인 경우 동일 리프 블록에 도달하기 때문에 적은 비용으로 쉽게 중복체크를 할 수 있다.

### 인덱스만을 읽는 검색

인덱스 검색시 먼저 인덱스를 읽은 후 리프노드에 저장된 실제 레코드 주소를 가지고 실제 데이터를 읽는 두단계를 거치게 된다.

하지만 검색 패턴에 따라 인덱스를 읽는 것만으로 처리가 완결되는 경우도 있다. 가격이 1000원 이하인 상품의 개수를 알고싶을 때, 가격 인덱스가 있으면 인덱스에서 `가격 <=1000`의 조건에 맞는 레코드 건수를 열거하는 것만으로 결과를 구할 수 있어 데이터 영역에 추가로 엑세스가 필요 없다.
이러한 작업을 `index only read`, `covering index`라고 한다.

## 업데이트 비용 절감을 위한 노력

인덱스는 검색 성능을 올리는 대신 업데이트 성능이 떨어지는 단점이 있다고 했다. 업데이트 비용을 최소화하기 위한 방법을 알아보자.

### 디스크에 모아서 기록하기

InnoDB는 업데이트된 정보를 메모리나 전용 파일에 일시적으로 기록하여 나중에 모아서 단번에 리프 블록을 갱신하는 구조를 택하고 있다. 인서트 버퍼를 사용한다.
이러한 구조에서는 random write보다 훨씬 빠른 sequential write를 사용한다.

### 병렬 갱신 성능 높이기

B+Tree 인덱스에 값의 추가, 갱신, 삭제를 할 경우 인덱스의 리프 노드의 내용을 이동시켜야 한다. 이러한 처리를 **리프 분할** 이라고 한다.

여러 클라이언트에서 일제히 업데이트가 발생해 리프 분할이 여기저기에서 일어날 경우 인덱스 트리의 일관성을 갖기가 매우 어렵다. 따라서 InnoDB에서는 인덱스의 재편성이 완료될 때 까지 일체의 참조/갱신 처리를 차단한다. 일관성을 갖게 되지만 대량으로 업데이트를 실행하여도 동시성이 그다지 높아지지 않는 문제가 남는다. 멀티코어 CPU환경으로 이러한 병렬 갱신 성능의 중요성도 높아졌다. B+Tree인덱스에는 lock free로 갱신하는 알고리즘도 제안되고 있다고 한다.

현재 이러한 문제를 해결하는 가장 빠른 방법은 `파티셔닝`을 하는 것이다. 내부적으로 테이블을 복수로 분할 관리해 인덱스도 복수로 구분하여 병렬 갱신이 가능하다.

---

**참고**

- Real Mysql
- 웹 프로그래머를 위한 데이터베이스를 지탱하는 기술
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner
