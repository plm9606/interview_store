**💌CONTENTS**

- [B-Tree 인덱스](#b-tree-인덱스)
  - [구조 및 특성](#구조-및-특성)
  - [B-Tree 인덱스 키 추가](#b-tree-인덱스-키-추가)
    - [B-Tree 인덱스 키 삭제](#b-tree-인덱스-키-삭제)
    - [B-Tee인덱스 키 변경](#b-tee인덱스-키-변경)
  - [B-Tree 인덱스 사용에 영향을 미치는 요소](#b-tree-인덱스-사용에-영향을-미치는-요소)
    - [인덱스 키값의 크기](#인덱스-키값의-크기)
    - [B-Tree 깊이](#b-tree-깊이)
    - [선택도(기수성)](#선택도기수성)
    - [읽어야 하는 레코드의 건수](#읽어야-하는-레코드의-건수)
  - [B-Tree 인덱스를 통한 데이터 읽기](#b-tree-인덱스를-통한-데이터-읽기)
    - [인덱스 레인지 스캔](#인덱스-레인지-스캔)
    - [인덱스 풀 스캔](#인덱스-풀-스캔)
    - [루스(loose) 인덱스 스캔](#루스loose-인덱스-스캔)

# B-Tree 인덱스

B는 binary가 아니라 balanced의 약자이다.
칼럼의 원래 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지하고 있다.

## 구조 및 특성

B-Tree는 트리구조 최상위에 하나의 `루트노드`가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다.
트리 가장 하위에 있는 노드를 `리프노드` 그 중간은 `브랜치 노드`라고 한다.

DB에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되고, 인덱스의 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.

## B-Tree 인덱스 키 추가

B-Tree에 저장될 때는 저장될 키값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정소를 B-Tree의 리프노드에 저장한다.

만약 리프노드가 꽉차서 더는 저장할 수 없을 때는 리프노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리 범위가 넓어져 상대적으로 쓰기 작업 시간이 오래 걸리는 것이다.

새로운 키값이 B-Tree에 저장될 때 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수도 잇고, 그렇지 않을 수도 있다. InnoDB 엔진은 상황에 따라 인덱스 키 추가 작업을 지연시킨다.

- 인서트 버퍼에 의해 인덱스 키 추가 작업이 지연되어 처리된다 하더라도 이는 사용자에게 아무런 악영향 없이 처리되므로 개발자는 이를 전혀 신경쓰지 않아도 된다.
- MySQL 5.5 이상부터는 `innodb_change_buffering` 설정을 이용해 키 추가/삭제 작업 중 어느 것을 지연처리 해야 할지 설정해야 한다.

### B-Tree 인덱스 키 삭제

해당 키 값이 저장된 B-Tree의 리프노드를 찾아 삭제 마크만 하면 된다.
마킹작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 IO가 필요한 작업이다.

### B-Tee인덱스 키 변경

먼저 키 값을 삭제한 후, 새로운 키값을 추가하는 방식으로 진행한다. 인덱스 키값에 따라 저장될 리프노드의 위치가 결정되기 때문이다.

## B-Tree 인덱스 사용에 영향을 미치는 요소

### 인덱스 키값의 크기

- `page`/`block`: InnoDB 스토리지엔진이 디스크에 읽기/쓰기 작업을 하는 최소 단위
  페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.

인덱스도 결국 `페이지`로 관리되며, B-Tree의 루트, 브랜치, 리프 노드를 구분한 기분이 바로 페이지 단위이다.
B-Tree는 일반적으로 자식 노드의 개수가 가변적인 구조이며 페이지 크기와 키값의 크기에 따라서 최대 자식노드의 수가 결정된다.

InnoDB의 페이지 크기는 `16KB`로 고정되어 있다. 만약 인덱스의 키가 16바이트이고 자식노드 주소가 평균 12바이트라면, 하나의 인덱스 페이지에는 585개를 저장할 수 있다. (16\*1024/(16+12)) 최종적으로 자식노드를 585개 가질 수 있는 B-Tree가 되는 것이다.

만약 인덱스 키값이 두배로 커진다면 어떻게 될까? 16\*1024/(32+12) = 372 개의 자식노드를 가질 수 있게 된다. 만약 500개 이상의 레코드를 읽어야하는 경우 전자는 인덱스 페이지 한번으로 해결될 수 있지만, 후자는 최소 2번 이상 디스크에서 페이지를 읽어와야 하므로 그만큼 느려질 수 밖에 없다.

페이지 뿐만 아니라 버퍼 풀이나 키캐시 등의 메모리에 캐시해 둘 수 있는 레코드 수가 줄어들기 때문에 메모리의 효율이 떨어지게 된다.

### B-Tree 깊이

B-Tree 인덱스의 깊이는 상당히 중요하지만 직접적으로 제어할 수 있는 방법은 없다.
B-Tree의 깊이는 Mysql에서 값을 검색할 때 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제이다. 인덱스의 키값이 커질수록 하나의 인덱스 페이지에 담을 수 있는 인덱스의 양은 적어지게 되고, 이로 인해 같은 개수의 인덱스라 할지라도 B-Tree의 깊이는 더 깊어져 더 많은 디스크 IO가 발생하게 된다.

depth가 3인 B-Tree에 인덱스를 저장한다고 가정하자.
키값이 16바이트인 경우 최재 2억(585*585*585)개 정도를 저장할 수 있는 반면
키값이 32바이트인 경우 최대 5천만(372*372*372)개를 저장할 수 있다.

실제로는 아무리 대용량 데이터베이스라 하더라도 깊이가 4-5이상 깊어지진 않는다고 한다. 하지만 키값의 크기가 깊이를 좌우한다는 점을 명심하자!

### 선택도(기수성)

모든 인덱스 가운데 유니크한 값의 수를 의미한다.
인덱스 키값 가운데 중복이 적을수록 (선택도가 높을수록) 검색 대상이 줄기 때문에 빠른 검색이 가능하다.

### 읽어야 하는 레코드의 건수

인덱스를 통해 테이블 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 보다 높은 비용이 드는 작업이다.
따라서 테이블 레코드 100만건에 대해서 50만건을 읽어야 하는 쿼리가 있을 때, 전체 테이블을 모두 읽어 필요 없는 50만건을 버리는 것이 빠른지, 인덱스를 통해 필요한 50만건만 읽어오는 것이 효율적일지 판단해야 한다.
일반적인 dbms옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 읽는 것 보다 4-5배 비용이 더 많이 드는 작업인 것으로 예측한다고 한다. 따라서 인덱스를 통해 읽어야 할 레코드 건수가 전체의 20~25%를 넘으면 테이블을 모두 읽는 것이 더 효율적이다.

## B-Tree 인덱스를 통한 데이터 읽기

어떻게 인덱스를 이용해서 실제 레코드를 읽어내는지 3가지 방법을 알아본다.

### 인덱스 레인지 스캔

인덱스 접근 방법 중 가장 대표적인 방법으로, 아래 두개 방법보다 빠른 방법이다. (그런데 아래의 두가지 방법이 존재하고 사용되는 이유는?)

인덱스 레인지 스캔은 검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식이다. 루트 노드에서부터 비교를 시작해 최종적으로 리프 노드까지 탖아들어가야 비로소 실제로 원하는 시작 지점을 찾을 수 있다.
이때 리프노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데 레코드 한건 단위로 랜덤IO가 한번씩 발생된다.
![](index_range_scan.jpg)

### 인덱스 풀 스캔

인덱스 레인지 스캔처럼 인덱스를 사용하지만 인덱스 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다. 쿼리 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. (a,b,c)칼럼 순으로 인덱스가 만들어져 있는데 b나 c칼럼으로 검색하는 경우가 그렇다.

![](index_full_scan.jpg)

먼저 리프 노드의 제일 앞 또는 뒤로 이동한 후, 리프노드를 연결하는 링크드 리스트를 따라 처음부터 끝가지 스캔하는 방식을 인덱스 풀 스캔이라고 한다.
인덱스 레인지 스캔보단 느리지만 테이블 풀 스캔보다는 효율적이다. 인덱스 전체 크기는 테이블 전체 크기보다 작기 때문이다.

### 루스(loose) 인덱스 스캔

루스 인덱스 스캔이란 말 그대로 듬성듬성하게 인덱스를 읽는 것을 의미한다. 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간중간 필요하지 않은 인덱스 키값은 무시하고 다음으로 넘어가는 방식으로 처리한다. 일반적으로 GROUP BY또는 MAX(), MIN()함수에 대해 최적화를 하는 경우에 사용된다.

```sql
select dept_no, min(emp_no)
from dept_emp
where dept_no between 'd002' and 'd004'
group by dept_no;
```

dept_emp 테이블은 dept_no와 emp_no두개의 칼럼으로 인덱스가 정렬되어 있다.
인덱스에서 where절을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다. 위의 쿼리를 실행하게 되면 dept_no 그룹별로 제일 텃번째 레코드의 emp_no만 읽으면 된다. emp_no가 이미 정렬이 되어있기 때문에 가장 첫 dept_no의 emp_no만 레코드 전체를 읽고 불필요한 부분은 나머지 레코드를 읽지 않고 다음으로 이동하는 것을 볼 수 있다.

![](index_loose_scan.jpg)

참고

- Real MySQL - 이성욱

