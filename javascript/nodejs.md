# Node.js

javascript를 브라우저 밖에서도 실행할 수 있도록 하는 javascript 런타임이다.

> 런타임: 특정 언어로 만든 프로그램을 실행할 수 있는 환경

## Node.js 구조

![](https://miro.medium.com/max/875/1*yEW6321eqBd_-C0D7LsBQw.png)

Node.js는 크게 내장 라이브러리, v8엔진, libuv로 구성되어 있다. Node.js의 특징인 이벤트기반, 논블로킹 IO모델들은 모두 libuv라이브러리에서 구현된다.

### v8엔진

자바스크립트를 C++로 변환해주는 역할을 한다.
구글에서 개발된 오픈 소스 JIT 가상 머신형식의 자바스크립트 엔진이며 구글 크롬 브라우저와 안드로이드 브라우저에 탑재된다.

V8은 자바스크립트를 바이트코드로 컴파일하거나 인터프리트하는 대신 실행하기 전 직접적인 기계어로 컴파일하여 성능을 향상시킨다. 추가적인 속도향상을 위해 인라인 캐싱과 같은 최적화 기법을 적용한다.

### 이벤트루프

이벤트루프는 여러개의 phase를 가지고 있고, pahse는 각각의 큐를 가지고 있는다. phase는 자신의 큐를 관리하고, 큐들은 fifo방식으로 CPU가 할당(=이벤트루프가 해당 phase를 호출할때)될 때 콜백 함수를 처리한다. 이벤트 루프는 RR방식으로 노드 프로세스가 종료될 때 까지 규칙에 따라 여러 phase를 순회한다.

**phase 종류**

![](https://miro.medium.com/max/875/1*EysVFSU5tYH-6nsg8ZSmNg.png)

- timers
  - setTimeout()같은 타이머 콜백이 처리된다.
  - 타이머 콜백 내부로직들은 poll큐에 먼저 등록된 콜백들이 처리되고 나중에 처리될 수도 있으므로, 파라미터로 지정한 시간에 딱 실행됨을 보장하지 못한다.
- pending Callbacks
  - 다음 루프 반복으로 연기된 I/O 완료 결과가 큐에 담깁니다. I/O 작업이 완료되면 다음번 루프에 이 단계에 들어와있게 되고, I/O 작업 블록내의 콜백함수들을 poll 단계의 큐로 넘겨줍니다. 또한 TCP 오류 같은 시스템 작업의 콜백을 실행.
- idle, prepare
  - 내부용으로만 사용
- poll
  - I/O와 연관된 콜백(클로즈 콜백, 타이머로 스케줄링된 콜백, `setImmediate()`를 제외한 거의 모든 콜백)을 실행
  - poll 큐에 쌓인 콜백함수들을 한도가 넘지 않을때까지 모두 동기적으로 실행. 만약 한도가 넘거나, 더이상 실행할 콜백함수가 없을때는 별도의 규칙을 따라, 다음 단계로 넘어가거나 대기
- check
  - `setImmediate()` 콜백은 여기서 호출되고 집행
- close callbacks
  - `on('close', ...)` 같은 것들이 여기서 처리됨

```js
fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log("A");
  }, 0);
  setImmediate(() => {
    console.log("B");
  });
});
```

위 코드를 실행하면 이벤트루프에서는 아래와 같은 순서로 동작한다.

1. fs.readFile 라는 블로킹작업을 만난 시점에 이벤트루프는 워커쓰레드에게 작업을 넘김
2. 워크쓰레드가 작업을 완료한 뒤 I/O callbacks 영역의 큐에 콜백을 등록
3. 이벤트루프가 I/O callbacks 영역을 실행할 때, 콜백을 poll 영역의 큐에 등록
4. 이벤트루프가 poll 영역을 실행할 때, 큐에 1개가 있으므로 이걸 실행함.
5. (콜백내부) 2라인에서 setTimeout() 이므로 다시 timers 영역에 넣고 5라인으로 간다.
6. (콜백내부) 5라인에서 setImmediate() 이므로 check 영역에 넣는다.
7. 이벤트루프가 poll 큐를 비우고, 다음 실행영역인 check 영역으로 간다. check 영역의 큐에는 들어있는 'B'를 콘솔에 찍는다. check 영역의 큐를 비우고 다시 while문의 시작지점으로 간다.
8. 이벤트루프가 timers 영역을 호출한다. uv\_\_run_timers()는 setTimeout()의 콜백을 poll큐에 등록한다.
9. 이벤트루프가 2번째로 poll 영역을 실행한다. 큐에 1개가 있으므로 이걸 실행하고 'A'를 찍는다.
10. node 프로세스가 반환되고 끝

이벤트 루프는 libuv내에서 구현된다. 이때 자바스크립트의 스레드와 이벤트 루프의 스레드가 별도로 존재하는 것이 아니다.

## 싱글 스레드

Node.js는 V8엔진 싱글 스레드로 동작하며 libuv(비동기식 I/O)를 사용한다. I/O가 발생하면 스레드 풀에 작업을 전달하게 되고, I/O가 완료되면 이벤트 큐에 콜백 함수를 쌓는다. 이벤트 루프는 항상 돌고 있다가 V8 엔진의 호출스택이 비워지면 이벤트 큐에서 작업을 처리한다. 작업이 완료될 때 까지 기다리지 않고 다른 작업을 먼저 처리 하면서 Blocking 없이 동기적인 작업처럼 동작하게 한다.

또한 Node.js는 클러스터링을 통해 프로세스를 포크(fork)하여 멀티스레드인것 처럼 사용될 수 있다. 트래픽에 따라서 프로세스를 포크할 수 있으므로 서버의 확장성이 용이하다는 장점이 있다.

자바스크립트를 실행하는 이벤트 루프만 싱글스레드인 것이지, IO작업 같은 블로킹 작업들은 뒤에서 libuv의 스레드 풀에서 실행된다. 이벤트루프만 블록킹 되지 않게 만들면 워커들은 알아서 일을 나눠가지고 돌아간다.

## Event-driven

event-dirven은 이벤트가 발생했을 때 미리 지정해둔 작업을 수행하는 방식을 말한다.
노드는 이벤트 리스너에 등록해둔 콜백함수를 실행하는 방식으로 동작한다.

## 논블로킹 I/O

노드는 http, db IO, api call, filesystem등 블로킹 작업들을 백그라운드(커널 또는 libuv의 스레드 풀)에서 수행하고, 이를 비동기 콜백함수로 이벤트 루프에 전달한다.

![](https://miro.medium.com/max/875/1*v2QSJRO5cmWGoLMvfAWfiQ.png)

libuv는 커널단(윈도우의 경우 IOCP, 리눅스는 AIO)에서 어떤 비동기 작업들을 지원해주는지 알고 있기때문에, 그런 종류의 작업들을 받으면, 커널의 비동기함수들을 호출한다. 작업이 완료되면 시스템콜을 libuv에게 던져준다. libuv 내에 있는 이벤트루프에게 콜백으로서 등록된다.

libuv의 워커쓰레드는 커널이 지원안하는 작업들을 수행한다. 대표적인 예로 소켓 작업류는 커널들이 이미 비동기로 지원하지만, 파일시스템쪽 작업은 지원하지 않는데(정확히는 지원하지만 libuv에서 추상화 문제로 안쓴다고 함) 이럴때 libuv의 쓰레드가 쓰인다.

**참고**

- https://sjh836.tistory.com/79
- https://sjh836.tistory.com/149
- https://medium.com/@vdongbin/node-js-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC-single-thread-event-driven-non-blocking-i-o-event-loop-ce97e58a8e21
